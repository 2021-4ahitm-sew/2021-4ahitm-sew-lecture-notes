= Lecture Notes 4ahitm SEW 20/21
Thomas W. Stütz
1.0.0, 2020-09-25: Some notes
ifndef::imagesdir[:imagesdir: images]
//:toc-placement!:  // prevents the generation of the doc at this position, so it can be printed afterwards
:sourcedir: ../src/main/java
:icons: font
:sectnums:    // Nummerierung der Überschriften / section numbering
:toc: left

//Need this blank line after ifdef, don't know why...
ifdef::backend-html5[]

// https://fontawesome.com/v4.7.0/icons/
//icon:file-text-o[link=https://raw.githubusercontent.com/htl-leonding-college/asciidoctor-docker-template/master/asciidocs/{docname}.adoc] ‏ ‏ ‎
//icon:github-square[link=https://github.com/htl-leonding-college/asciidoctor-docker-template] ‏ ‏ ‎
//icon:home[link=https://htl-leonding.github.io/]
endif::backend-html5[]

====
Testtermin: 4.12.2020
Prüfungen:
====

== 2020-09-22

* http://edufs.edu.htl-leonding.ac.at/~t.stuetz/download/nvs/presentations.2021/00_java.oekosystem.pdf[00_java.oekosystem.pdf, window="_blank"]
* http://edufs.edu.htl-leonding.ac.at/~t.stuetz/download/nvs/presentations.2021/01_Introduction.pdf[01_Introduction.pdf, window="_blank"]
* http://edufs.edu.htl-leonding.ac.at/~t.stuetz/download/nvs/presentations.2021/01_NVS_Uebersicht.pdf[01a_NVS_Uebersicht.pdf, window="_blank"]
* http://edufs.edu.htl-leonding.ac.at/~t.stuetz/download/nvs/presentations.2021/02_microprofile.pdf[02_microprofile.pdf, window="_blank"]

[plantuml,twotier,png]
----
@startuml
database db
rectangle Quarkus as quarkus
rectangle Server
rectangle "Client (Browser)" as client

db -- quarkus
quarkus <-> Server : restful services
Server <- client : request
Server -> client : response
@enduml
----

== 2020-09-25

* Was ist ein REST-Service?

* Präsentation 04_REST_Uebersicht besprochen (bis Folie 20 - EFSP)
* http://edufs.edu.htl-leonding.ac.at/~t.stuetz/download/nvs/presentations.2021/02_microprofile.pdf[04_REST_Uebersicht, window="_blank"]

=== Begriff des Marshalling

[plantuml,marshalling,png]
----
@startuml
storage "java-object" as javaobject
file json
javaobject -right-> json :marshalling >
@enduml
----

[plantuml,unmarshalling,png]
----
@startuml
storage "java-object" as javaobject
file json
javaobject <-right- json :< unmarshalling
@enduml
----


== 2020-09-29

maven Lifecycle

=== Mögliche REST-Clients

* Browser
* Browser-Extension
** RESTClient
* REST-Client in IDE (files mit .http-Endung)
* CLI-clients
** cURL
** httpie `http :8080/person Accept:application/json`
* Standalone Clients
** Postman
** Insomnia
* Selbstprogrammierte Clients


=== MediaType in Produces

schränkt die möglichen MIME-Types ein


=== Rückgabetypen

* String
* Entity - Klasse
** JAXB - XML-Binding (XML-Marshalling)
** JSON-B - Json-Binding (Json-Marshalling)
* JsonObject / JsonArray / JsonValue
* Response
** Statuscode kann gewählt werden
** Header-Entries können hinzugefügt werden
** uvam.

== 2020-10-02

.Was ist? (Erläuterung und Abrenzung)
- Jakarta EE
- microprofile
- Quarkus

.Resourcen
- http://edufs.edu.htl-leonding.ac.at/~t.stuetz/download/nvs/presentations.2021/04_REST_Uebersicht.pdf[04_REST_Uebersicht.pdf, window="_blank"]


== 2020-10-06

* REST wiederholt
* POST & PUT Methoden erstellt und ausprobiert (CRUD)
* JsonValue, JsonObject & JsonArray verglichen
* Typen von Parametern besprochen
** https://mincong.io/2018/11/27/jax-rs-parameters/#overview


.Mikroprojekte - Themenvergabe
//[%collapsible%open]
[%collapsible]
====
[cols="1,5,5,2"]
|===
|lfd.Nr. |Name |Thema |-

|{counter:usage}
|BM
|Friedhofsverwaltung
|

|{counter:usage}
|DJ
|Produktionsbetrieb (Fließband)
|

|{counter:usage}
|DF
|Centermanager
|

|{counter:usage}
|EQ
|Baustellenkoordinator
|

|{counter:usage}
|EP
|Baumschule
|

|{counter:usage}
|FS
|Kochrezepte
|

|{counter:usage}
|FJ
|Farmverwaltung
|

|{counter:usage}
|HT
|Optiker
|

|{counter:usage}
|KS
|Facility Management
|

|{counter:usage}
|KF
|Zooverwaltung
|

|{counter:usage}
|KS2
|Event-Manager
|

|{counter:usage}
|MR
|Reisebüro
|

|{counter:usage}
|MA
|Plattenlabel
|

|{counter:usage}
|OJ
|Tanzschule
|

|{counter:usage}
|PV
|Skischule
|

|{counter:usage}
|RJ
|Fitnessstudio
|

|{counter:usage}
|SS
|Fakturierung
|

|{counter:usage}
|SL
|Kfz-Händler
|icon:uncheck[]

|{counter:usage}
|SM
|Friseurladen
|icon:uncheck[]

|{counter:usage}
|TS
|Restaurant
|icon:uncheck[]

|{counter:usage}
|TK
|Callcenter
|icon:uncheck[]

|{counter:usage}
|TI
|Busreisen (inkl Schulbusse)
|

|{counter:usage}
|WN
|Autovermietung
|

|{counter:usage}
|WJ
|Parkplatzverwaltung
|icon:uncheck[]

|===

====

=== Assignment 01: Erstellen von Endpoints für eine Entität mit CRUD-Funktionalität

* Erstellen Sie ein Quarkus-Projekt mit folgender Bezeichnung:
. nachname-projektname zB mustermann-restaurant
. Im Package `at.htl.<projektname>.entity` zB. `at.htl.restaurant.entity` erstellen Sie eine Entitätsklasse zB Product
   (in diesem Restaurant sind die Produkte die Speisen und Getränke)
. Die Daten der Stammdaten sind in einer Collection in einem geeigneten Repository zu speichern
(Es ist KEINE Datenbank zu verwenden).
. Im Package `at.htl.<projektname>.boundary` (zB `at.htl.restaurant.boundary`) erstellen
Sie ein Klasse <Entity>Service.java zB ProductService.java
. In dieser Klasse erstellen Sie mehrere Endpoints, um die CRUD-Funktionalität für die von Ihnen
gewählte Entität zu implementieren.
. In einem File `request.http` erstellen Sie die geeigneten Request, um ihre Endppoints auzuprobieren
. Die Requests funktionieren mit Daten wahlweise im JSON- oder XML-Format
. Verwenden Sie Swagger, um Ihre Endpoints zu dokumentieren
. Im README.md ihres Repos dokumentieren Sie dieser (erste) Aufgabe rudimentär.
. Vergessen sie nicht, die nicht in das github-repo zu speichernden Dateien zu exkludieren.
. Für jeden Endpoint ist ein Commit mit einer aussagekräftigen Message zu erstellen.
. *Abgabe bis 12.Oktober 2020, 23:59*
. Den Link zum Classroom-Repository finden Sie im Discord.

TIP: Verwenden Sie eine Stammdatenklasse.

----
____   ____.__       .__    ___________        _____      .__
\   \ /   /|__| ____ |  |   \_   _____/_______/ ____\____ |  |    ____
 \   Y   / |  |/ __ \|  |    |    __)_\_  __ \   __\/  _ \|  |   / ___\
  \     /  |  \  ___/|  |__  |        \|  | \/|  | (  <_> )  |__/ /_/  >
   \___/   |__|\___  >____/ /_______  /|__|   |__|  \____/|____/\___  /
                   \/               \/                         /_____/
----

== 2020-10-13

=== Testen Allgemein

* Unterschied
** Unit Test
** Integration Test
* TDD
* Coverage
** Wie viel macht Sinn
*** Happy Path & Edge Cases
*** Was muss man eventuell nicht automatisiert(!) testen
** mehrere mögliche Programmläufe durch Verzweigungen

=== Quarkus Tests

* Besprechung was im Hintergrund eigentlich alles passiert
* Syntax (& Packages)
* Was sollte man damit testen
* Tests gemeinsam erstellt für:
** Statuscode
** Body Content

== Benotung Assignment 1 - Entities mit CRUD - Funktionalität

Noten sind (demnächst) im
https://edufs.edu.htl-leonding.ac.at/moodle/course/view.php?id=2931[Moodle-Kurs]
abrufbar.


.Bewertung Assignment 1 - Download am 2020-10-14 11:42
[%collapsible%open]
//[%collapsible]
====
[cols="1,1,8,2"]
|===
|lfd.Nr. |Name |Kommentar |Note

|{counter:katalognr}
|BM
a|
* Thema: Friedhofsverwaltung
* nicht lauffähig
* keine Endpoints
* das heißt nicht cementry, sondern CEMETERY oder GRAVEYARD
* Dir fehlen sämtliche Projektdateien (mvnw, pom.xml, .gitignore, ...)
* Felder in einer Klasse sind private (-> Geheimnisprinzip)
+
[source,java]
----
public class Person {

    Integer id;
    String name = "";
    LocalDateTime bday;
    String causeOfDeath = "";

    public Person(Integer id, String name, LocalDateTime bday, String causeOfDeath) {
        this.id = id;
        this.name = name;
        this.bday = bday;
        this.causeOfDeath = causeOfDeath;
    }
    //...
}
----
** besser wäre eine Entität Grab(*`grave`*), die ist wohl am Wichtigsten
(mit einem Feld `Ansprechperson` (`contact`))
** Person ist schon ok, aber erst später. BTW: Die Todesursache geht keinen was an
(ev. auch hier eine Kontaktperson i.S.v. Kunde)
|ngd(5)

|{counter:katalognr}
|DJ
a|
* Thema: Produktionsbetrieb (Fließband)
* sehr ausführliche Dokumentation im README.md
* .gitignore
** Wenn Du den gesamten `.idea`-Ordner ausschließt, verlierst Du auch jedes mal Deine Datasources etc
** besser ist es, nur `workspace.xml` auszuschließen
* PATCH fehlt
* employee.http hat falsche urls

*Bravo*
|sgt(1)

|{counter:katalognr}
|DF
a|
* Thema: Centermanager
* Einen Schönheitspreis gewinnt Dein Algorithmus nicht
image:dumfarth-string-concat.png[]
** StringBuilder?
** sprechende Methodennamen: hello(...) ?
* Du hättest ev. auch mal einen Objekttyp (Entityklasse) als Parametertyp nehmen können
* Wenn Du sowieso nur ein JsonObject erwartest, dann kannst Du ruhig JsonObjekt als Datentyp nehmen und nicht immer JsonValue
* Bei einem REST-Endpoint keine Webseiten zurückgeben (auch wenn es gut aussieht) -> Stichwort: maschinenlesbar
image:dumfahrt-get.png[]
** Für Webseiten kannst Du index.html verwenden
** besser JSON, XML, ...
* Testdaten -> Bravo
|sgt(1)

|{counter:katalognr}
|EQ
a|
* Thema: Baustellenkoordinator
* sehr aufmerksam -> XmlLocalDateAdapter

.Implementierung des XmlAdapters
[source,java]
----
import javax.xml.bind.annotation.adapters.XmlAdapter;
import java.time.LocalDate;

public class XmlLocalDateAdapter extends XmlAdapter<String, LocalDate> {


    @Override
    public LocalDate unmarshal(String s) {
        return LocalDate.parse(s);
    }

    @Override
    public String marshal(LocalDate localDate) {
        return localDate.toString();
    }
}
----

.Verwendung des XmlAdapters
[source,java]
----
@XmlRootElement
public class Construction {
    // ...
    @XmlJavaTypeAdapter(value = XmlLocalDateAdapter.class)
    public void setDeadLine(LocalDate deadLine) {
        this.deadLine = deadLine;
    }
    // ...
}
----

see also https://blog.sebastian-daschner.com/entries/jaxrs-convert-params[Converting JAX-RS parameters with ParamConverters, window="_blank"]

* Response beim POST nicht korrekt, aber fast
----
POST http://localhost:8080/constructions

HTTP/1.1 201 Created
Content-Length: 0
Location: http://localhost:8080/constructions  //<.>

<Response body is empty>

Response code: 201 (Created); Time: 28ms; Content length: 0 bytes
----

<.> hier sollte die Resource *des Elements* stehen

.ConstructionService
[source,java]
----
@Path("/constructions")
public class ConstructionService {
    //...
    @POST
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    public Response create(Construction construction, @Context UriInfo uriInfo) {
        ConstructionRepository
                .getInstance()
                .create(construction);  // <.>

        return Response.created(uriInfo
                .getAbsolutePathBuilder()
                 //.path(Integer.toString(id))
                .build())
                .build();
    }
    //...
}
----

<.> hier wäre die Rückgabe des Schlüssels vorteilhaft,
der dann in die Location hinzugefügt werden kann
(siehe auskommentierten Code).

* Git-Commits ok

|sgt(1)

|{counter:katalognr}
|EP
a|
* Thema: Baumschule
* gut in README.md dokumentiert
* Aktueller Quarkus 1.8.1
* leider keine vollständige CRUD-Funktionalität
|bef(3)

|{counter:katalognr}
|FS
a|
* Thema: Kochrezepte
* Die geborene Köchin
image:feichtinger-putenschnitzel.png[]
* Für die Parameter gilt das selbe wie bei Felix
* Für Deine Algorithmen gilt ebenfalls exakt dasselbe wie bei Felix
* Testdaten -> Bravo (ebenfalls wie bei Felix)
| sgt(1)

|{counter:katalognr}
|FJ
a|
* Thema: Farmverwaltung
* Tolle Farmverwaltung

.Product.java
[source,java]
----
package at.htl.fitzinger_farmverwaltung.entity;

public class Product {
}
----

.ProductService.java
[source,java]
----
package at.htl.fitzinger_farmverwaltung.boundary;

public class ProductService {
}
----

.ProductRepository.java
[source,java]
----
package at.htl.fitzinger_farmverwaltung.entity;

import java.util.ArrayList;

public class ProductRepository {
    ArrayList<Product> products = new ArrayList<Product>();
}
----
|ngd(5)

|{counter:katalognr}
|HT
a|
* Thema Optiker
* nur leere Klassen

[source,java]
----
package at.htl.hoefler_optiker.entity;

public class Product {
}
----

[source,java]
----
package at.htl.hoefler_optiker.entity;

import java.util.ArrayList;

public class ProductRepository {
    ArrayList<Product> productList = new ArrayList<Product>();
}
----
|ngd(5)

|{counter:katalognr}
|KS
a|
* Thema: Facility Management
* Sehr witzig, wo sind die ganzen maven-Files?
image:kalinke-project-contents.png[]
+
image:klausner-leeres-repo.png[]

* Warum gibst Du immer eine Liste zurück?

[source,java]
----
public class BuildingRepository {

    private final List<Building> buildings = new ArrayList<>();

    //...
    public List<Building> addEntity(Building building) {
        buildings.add(building);
        return buildings;
    }

    public List<Building> removeEntity(Building buildingToRemove) {
        for (Building buildingEntry : buildings) {
            if (buildingEntry.getType().equals(buildingToRemove.getType())) {
                buildings.remove(buildingEntry);
                return buildings;
            }
        }
        return buildings;
    }
    //...
}


----
* Das ist *keine* CRUD-Funktionalität (nur GET)
+
image:kalinke-crud.png[]
|gen(4)

|{counter:katalognr}
|KF
a|
* Thema: Zooverwaltung
* leider leeres Repo abgegeben
|ngd(5)

|{counter:katalognr}
|KS2
a|
* Thema: Event-Manager
* völlig leer, nicht mal ein leeres Projekt
|ngd(5)

|{counter:katalognr}
|MR
a|
* Thema: Reisebüro
* .gitignore -> siehe Dorfinger
* `http://localhost:8080/reise` -> siehe Dumfarth
** Ist cool gelöst, mit den unterschiedlichen MIME-Types
|sgt(1)

|{counter:katalognr}
|MA
a|
- Thema: Plattenlabel
- nur 2 leere Klassen (Label und Mitarbeiter)
- Anmerkung: Klassen sollten englisch benannt werden
|ngd(5)

|{counter:katalognr}
|OJ
a|
* Thema: Tanzschule
* Im `jonasoirer`-Repo hast Du ein Verzeichnis `oirer-tanzschule`,
in dem man dann das Projektverzeichnis `oirer-tanzschule` findet.
-> *Das ist eindeutig zu tief verschachtelt* +
+
image:oirer-folder-structure.png[width=300]
* Beim Repository ist eine Datenelement einzufügen (add),
nicht die bestehende Collection durch eine andere zu ersetzen (set)
+
[source,java]
----
public class DancingRepository {

    private List<DancingTeacher> repository = new ArrayList<>();

    public DancingRepository() {
        setRepository();
    }

    private void setRepository() {
        repository.add(new DancingTeacher(1, "Jonas", "Oirer"));
        repository.add(new DancingTeacher(2, "Aleks", "Vidakovic"));
    }

    public List<DancingTeacher> getRepository() {
        return repository;
    }

    @Override
    public String toString() {
        return "DancingRepository{" +
                "repository=" + repository +
                '}';
    }
}
----

** Man kann nichts hinzufügen
** Man kann nichts löschen
** Man kann nichts ändern
** Man kann kein einzelnes Datenelement abrufen
* Deine Packages und Klassen sind unstrukturiert
image:oirer-packages.png[]
** in das Package entity gehören nur entity-Klassen, keine Endpoints und auch kein Repository
* openapi / swagger sind *NICHT* installiert
* dein request.http ist
** unvollständig und
** fehlerhaft (PUT ohne body)
* Was ist da nicht optimal?
+
[source,java]
----
@Path("/dancer")
public class DancingTeacherService {
    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String hello() {
        return "hello oiropean dancers!";
    }

    private String coolestTeacher;

    @PUT
    @Path("coolest")
    @Consumes(MediaType.APPLICATION_JSON)
    public String getCoolestTeacher(DancingTeacher dancingTeacher) {
        this.coolestTeacher = dancingTeacher.getFirstName();
        return String.format("%s is the best", this.coolestTeacher);
    }
}
----

* Routen sollten nie im camel-Case sein, sondern kebab-case
|gen(4)

|{counter:katalognr}
|PV
a|
* Thema: Skischule
* sehr umfangreich

|sgt(1)

|{counter:katalognr}
|RJ
a|
* Thema: Fitnessstudio
* leider nur ein leeres Projekt abgegeben
|ngd(5)

|{counter:katalognr}
|SS
a|
* Thema: Fakturierung
* Die Bezeichner (der Klassen) sollten englisch sein
* Die Requests funktionieren nur im JSON-Format. Nicht wie in der Angabe gefordert auch im XML-Format
|sgt(1)

|{counter:katalognr}
|SL
a|
* Thema: Kfz-Händler
* Sehr umfangraich und sauber
* Ein Datum wäre gut gewesen
|sgt(1)

|{counter:katalognr}
|SM
a|
* Thema Friseurladen
* das kann wohl nicht funktionieren!
** Wo wird der bodey des requests eingelesen
** keine Groß-/Kleinschreibung bei Routen
** Du legst bei jedem Request ein eigenes Repository an (?!)

[source,java]
----
@Path("/person")
public class FriseurService {
    //...
    @POST
    @Path("/friseurJSON")
    @Produces(MediaType.APPLICATION_JSON)
    public List<Friseur> getFriseurList(){
        if (repository.friseure.size()== 0) {
            repository.createRepository();
        }
            return repository.friseure;
    }
    //...
}
----
|bef(3)

|{counter:katalognr}
|TS
a|
* Thema Restaurant
* beim POST muss man sicherstellen, dass bei mehrmaligen ausführen das Element nur einmal hinzugefügt wird
* es ist aber sehr sauber programmiert
|sgt(1)

|{counter:katalognr}
|TK
a|
* Thema: Callcenter
* Dir fehlen sämtliche Projektdateien (mvnw, pom.xml, .gitignore, ...)
* Die Klassennamen sollten immer in Englisch sein (alle Bezeichner)
* CRUD nicht vollständig implementiert
* nicht lauffähig
|gen(4)

|{counter:katalognr}
|TI
a|
* Thema: Busreisen (inkl Schulbusse)
* Grundsätzlich sehr sauber
* Es sollte auch möglich sein, nur einzelne Elemente zu lesen
* Warum ist beim GET nur XML möglich?
* Du solltest packages verwenden
* git commits sind ok
|gut(2)

|{counter:katalognr}
|WN
a|
* Thema Autovermietung
* Image-Links in README.md broken
* git-kommentar "zwischencommit" ist nicht sehr sprechensd
* Man sollte ein Element nur einmal posten können
** beim POST muss man sicherstellen, dass bei mehrmaligen ausführen das Element nur einmal hinzugefügt wird
|sgt(1)

|{counter:katalognr}
|WJ
a|
* Thema Parkplatzverwaltung
* ad README.md -> Du solltest Dir wirklich ansehen, wie man images in markdown files verlinkt
* Du Minimalist
|sgt(1)

|===

.Kriterien
* Das Projekt muss lauffähig sein (am Besten in ein neues Verzeichnis clonen und ausprobieren)
* Testdaten sind sehr hilfreich

.Allgemeine Bemerkungen
* Bezeichner in englisch (ist so üblich)
* ist eine List wirklich die geeignete Collection für das Repository
* der erste url einer RESTful-API sollte `/api` sein  (ebenfalls sehr oft üblich)

.Was ist zu tun
* Fehlerbehandlung -> WebException
* Wie sind die Responses aufgebaut?
* Kalenderdatum als Parameter bzw Datenbestandteil

====



== 2020-11-06 CDI - Context and Dependency Injection

http://edufs.edu.htl-leonding.ac.at/~t.stuetz/download/nvs/presentations.2021/07%20CDI.pdf[Skriptum CDI]

* Scope ... (Gültigkeits-)Bereich
** zB Gültigkeitsbereich bei Variablen (i.N. ein Block)
** zB Lebensdauer von Objekten (ApplicationScoped, SessionScoped, RequestScoped)
** ...

* CDI
** C ... Context ... Lebensdauer der Objekte
** DI ... Dependency Injection ... Injizieren einer Abhängigkeit

* Was bringt CDI?
** Inversion of Control / IoC: Das Programm muss sich nicht  mehr um die Erstellung
von Objekten kümmern, das übernimmt der Container
** Dies führt zu wenig fehleranfälligen Programmen
*** Um Erstellen/Zuweisen/Löschen der Objekte kümmert sich der Container
*** Man kann einfach die Konfiguration ändern
**** Testcontainer mit Testobjekten
**** Produktiv-Containe mit Real-Life-Objekten

* https://www.dev-insider.de/was-ist-eine-dependency-a-899057/[Dependency, window="_blank"]
** Eine Dependency oder Abhängigkeit beschreibt in der Softwareentwicklung, dass ein Programm ein bestimmtes Stück Code (z. B. Frameworks, Bibliotheken, Klasse) benötigt, um ordnungsgemäß zu funktionieren.

* Wie kann ein Objekt erstellt werden?
** Durch Verwendung des Schlüsselwortes `new`
** Durch Verwendung von Design Patterns (Entwurfsmuster)
*** zB einer Factory (Design Pattern)
*** zB eines Builder Pattern (Erbauer)
** Durch Dependency Injection

.Objekterstellung mit "new"
image:object-creation-with-new.png[]

* Erstellt man ein Objekt mit "new", so ist man selbst für die Lebensdauer verantwortlich
** Man kann das obige Person-Objekt löschen, indem man die Referenz auf das Objekt löscht
** Der Garbage Collector gibt den Speicherpaltz des Objekts frei.

.Durch NULL-setzen der Refernzvariablen wird der Speicherplatz freigegeben.
image:objcect-deletion.png[]

* Bei CDI ist der sogenannte DI-Container verantwortlich für
** das Erstellen von Objekten
** das Zuweisen zu einem Context (Lebensdauer)
** das Zuweisen von Objekten zu Variablen
** das Löschen von Objekten (Freigeben des Speicherplatzes)
** man spricht von "container-managed" Objekten oder auch Java-Beans
** Durch Verwendung von Annotation (@ApplicationScoped, @SessionScoped, @RequestScoped) kann
man die Lebensdauer beeinflussen.
** Mit *@Inject* kann der Developer eine Instanz einer Klasse anfordern.

* The *container* is the environment where your application runs.

* Was ist ein *Servlet*
** Ein Servlet ist *DIE* Methode, um Java-Code aus dem Internet (mittels TCP/IP))
aufrufen zu können
** Viele Bibliotheken zB JAX-RS, JSF usw verwenden im Hintergrund Servlets.


=== Logging in Jakarta EE (Quarkus)

https://quarkus.io/guides/logging

* Es wird empfohlen den jboss-Logger zu verwenden.


[source,java]
----
@ApplicationScoped
public class GreetingService {

    private static final Logger logger = Logger
            .getLogger(GreetingService.class.getSimpleName()); // <.>

    int counter;

    public String greeting(String name) {
        logger.info(String.format("Hello %s (%d x verwendet)", name, ++counter)); // <.>
        return String.format("Hello %s (%d x verwendet)", name, ++counter);
    }
}
----
<.> Man muss einen Logger deklarieren. Der Klassenname wird übergeben.
<.> Man kann den Logger verwenden

.Output des Loggers in Console
----
2020-11-06 09:40:53,795 INFO  [at.htl.con.GreetingService] (executor-thread-198) Hello susi (1 x verwendet!)
----

* Es gibt *Log-Levels*
** INFO
** ERROR
** FATAL
** DEBUG
** ...

* Es gibt sogenannte *Appender* zur Ausgabe auf verschiedenen Medien
** Konsole
** in Text-Files (auch rotierend)
** in Datenbanken
** auf einen REST-Endpoint
** ...

==== Logging mit Dependency Injection

Man kann auch einen Logger mit DI injizieren

.Erstellen des Producers
[source,java]
----
public class LoggerProducer {

    @Produces
    public Logger produceLogger(InjectionPoint injectionPoint) {
        return Logger.getLogger(injectionPoint.getBean().getBeanClass());
    }
}
----

.Verwendung des injizierten Loggers
[source,java]
----
@ApplicationScoped
public class GreetingService {

    @Inject
    private Logger logger; // <.>

    int counter;

    public String greeting(String name) {
        logger.info(String.format("Hello %s (%d x verwendet!)", name, ++counter)); // <.>
        return String.format("Hello %s (%d x verwendet!)", name, ++counter);
    }

}
----

<.> Die Logger Klasse wird injiziert.
<.> Die Verwendung bleibt gleich


=== [.line-through]#Offene# Punkte

* Warum funktioniert CDI nicht im Constructor?
* Was kann ich machen, um trotzdem CDI bei der Erstellung von Objekten zu verwenden? -> @PostConstruct
* Autostart in Quarkus-Apps (@Observer)


== 2020-11-13

=== Testen

image:testing.png[]

.V-Modell
image:v-modell.png[]

=== restAssured + assertJ


* Vocabulary
** specification ... techn. Beschreibung
** validieren ... auf Gültigkeit überprüfen
** verifizieren ... auf Korrektheit überprüfen
** route ... der Pfad in der URI nach dem Host und dem Port

image:request-reponse-structure.png[]

https://www.toolsqa.com/rest-assured/post-request-using-rest-assured/

==== GET-Request

* Es wird automatisch localhost:8080 verwendet
* Alternative: .when().get("http://localhost:8080/person")

[source,java]
----
    @Test
    public void testPersonEndpoint() {
        var person =
            // arrange
            given()
            // act
            .when().get("/person")
            // assert -> Rückgabe überprüfen
            .then()
                .statusCode(200)  // wir validieren
                .extract()
                   .body()
                   .as(Person.class);
        assertThat(person).isNotNull();
        assertThat(person.getName())
                .isNotNull()
                .isNotEmpty()
                .isEqualTo("Sepp");
    }
----

==== POST-Request

[source,java]
----
    @Test
    public void testPostPersonEndpoint() {

                given()
                // arrange
                   .contentType(ContentType.JSON)
                   .body(  // Text Blocks // <.>
                       """
                        {
                          "vorname":"Markus",
                          "nachname":"H"
                        }
                        """)
                   // act
                   .when().post("/person/jsontype")
                   .then()
                   .statusCode(200);  // wir validieren
    }
----

<.> Verwendung von Text-Blocks ab Java 15 (-> pom.xml) +
bis Java 14

[source,java]
----
.body("{\"vorname\": \"Markus\", \"nachname\": \"H\"}")
----


=== Startup-Methode in Quarkus

* wird nach dem Start der Applikation ausgeführt.

[source,java]
----
@ApplicationScoped
public class InitBean {

    // vergleichbar mit main()-MEthode
    void onStart(@Observes StartupEvent event) {
        LOG.info("The application is starting ...");
    }

}
----

=== PostConstruct-Methode

* Man kann injizierte Resourcen (Objekte) im Konstruktor nicht verwenden,
da sie erst nach der Ausführung des Konstruktors injiziert werden.

[source,java]
----
@ApplicationScoped
public class InitBean {

    @Inject
    GreetingService greetingService;

    public InitBean() {
        // hier kann man greetingService noch nicht verwenden
    }

    @PostConstruct
    private void init() {  // <.>
        greetingService.greeting("Jonas 1");
    }
}

----

<.> Diese Methode wird ausgeführt:

* nachdem das Objekt fertig gebaut ist (der Konstruktor wurde bereits ausgeführt)
* nachdem die Resourcen injiziert wurden
-> daher kann man diese Resourcen auch hier verwenden


=== Verwendung einer Datenbank

* Persistierung mit JPA

== 2020-11-13

==== Vorgangsweise beim Einrichten

zB Die Objekte einer Klasse Person sollen in einer DB persisitiert werden

* Bibliotheken zur pom.xml hinzufügen
** zB Hibernate / JPA
** JDBC-Treiber der Datenbank (postgres-jdbc-driver)
* Einrichten der zugangsdaten in `application.properties`
** jdbc-url
** username
** password
* Datenbank einrichten und starten
** zB mit Docker
* Entity-Klasse Person vorbereiten
** @Entity als Klassen-Annotation
** `Long id` hinzufügen mit Annotation @Id
** Ev. einer Id-Generator annotieren
*** 3 Strategien (AUTO ist keine eigene Strategie)
*** TABLE
*** IDENTITY
*** SEQUENCE
*** AUTO
* Injizieren Eines EntitiyManagers
* Bei schreibenden Operationen Annotation `@Transactional` verwenden.

Voíla ... jetzt kann man persistieren

== 2020-11-17 - Forts. JPA mit Quarkus

=== DB Setup

Wir verwenden als Beispiel Postgres (weil open source, sehr verbreitet und flexibel).

.DB herdockern
[source,bash]
----
docker pull postgres
docker run --name postgres --rm -e POSTGRES_PASSWORD=postgres -d -p 5432:5432 -v $HOME/databases/postgres:/var/lib/postgresql/data postgres
----

Anschließend die db anlegen (`create database quarkdb`).

=== Project Config

Zwei Dependencies:

* `io.quarkus:quarkus-hibernate-orm`
* JDBC driver (z.B. `quarkus-jdbc-postgresql`)

Hinzufügen via 'add with maven' Command von der https://code.quarkus.io website.

.DB Connection konfigurieren
[source,bash]
----
# datasource configuration
quarkus.datasource.db-kind = postgresql
quarkus.datasource.username = postgres
quarkus.datasource.password = postgres
quarkus.datasource.jdbc.url = jdbc:postgresql://localhost:5432/quark-db

# drop and create the database at startup (use `update` to only update the schema)
quarkus.hibernate-orm.database.generation=drop-and-create
----

=== Entity anlegen & verwenden

* Entities annotieren (`@Entity`, `@Id`,...) (s.o.)
** Serialisierungsoptionen für `enum`
** Relationen (1:1, 1:n, m:n) entsprechend abbilden
*** Angabe des Foreign Key
*** Cascade Optionen
* Repository in Service injecten
* `EntityManager` in Repository injecten
* Service Methode mit `@Transactional` annotieren
** Im Service und nicht im Repo, weil wir ggf. mehrere Operationen zusammenfassen!
*** LUW!

=== Queries

* Abfragen werden mit *JPQL* erstellt
** Ähnlich SQL aber mit Abwandlungen/Erweiterungen wie:
*** Joins über Referenzen "implizit" möglich
*** Objekte (new) können angelegt werden
*** Abfragen auf Class- und nicht auf Tablename
*** ...
** Placeholder (prepared statement) zwecks SQL Injection Vermeidung
* Zwei Optionen:
** (Typed)Queries direkt über den `EntityManager` erstellen
** NamedQueries in der Entity class definieren
* Laden verbundener Entitäten:
** Lazy Loading
** Eager Loading

== Strategien für Primärschlüsselerstellung

* IDENTITY
** Autowert, AutoIncrement -> in einem Tabellenfeld wird automatisch ein Zähler hochgezählt
* SEQUENCE
** Die Sequence ist ein eigenständiges Datenbankobjekt, die eine Folge von Zahlen generiert
** in Reihenfolge, zufällig, rollieren usw.
** kann man mit der Annotation @SequenceGenerator im Code erstellem
* TABLE
** die einfachste Variante
** eine Tabelle (meist mit Namen SEQUENCE) hat ein Feld mit einer Zahl, die mit UPDATEs hochgezählt wird
** Manchmal hat man für jede Tabellen-Id eine eigene Zeile
* AUTO
** eine der obigen Staretgien wird automatisch gewählt (meist TABLE)



== 2020-11-17
Prof. Haslinger

=== Persistieren mit Enums und Referenzen zwischen Klassen

[source,java]
----
@Enumerated(EnumType.ORDINAL) // <.>
private Gender gender;
----

<.> Der enum Wert wird als String in DB gespeichert

=== Fetching EAGER vs LAZY

=== Bidirektionale Beziehungen

[plantuml,bidirect,png]
----
@startuml
class Person {
  hobbies: List<Person>
}

class Hobby {
  person: Person
}
Person <-- Hobby : person <
Hobby <-- Person : List<Hobby> <
@enduml
----

* Problem: wird ein `Hobby` in `hobbies` eingetragen,

.Wird in in einem Hobby-Objekt eine Person eingetragen
[source,java]
----
public void setPerson(Person person) {
    this.person = person;
    person.getHobbies().add(this); // <.>
}
----

<.> Man aktualisiert

== 2020-12-01

=== Datenmodell

* Stammdaten meist über Bewegungsdaten assoziiert
* Repository-Pattern
** keine Repositories für schwache Entitäten
** -> https://docs.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/infrastructure-persistence-layer-design#define-one-repository-per-aggregate


=== Test

* zuerst Use-Cases / User-Stories definieren und dann
* Tests für die einzelnen Use-Cases / User-Stories schreiben
** System-Tests (Endpoints)
*** zB ein Produkt anlegen
*** zB einen Kunden anlegen
*** zB eine Rechnung mit drei Rechnungspositionen erstellen
** Integrations-Tests (zB für Repository-Klassen)
*** vor allem Dingen die Assoziationen
**** unidirektional
**** wenn bidirektional, das Einfügen und löschen von Objekten AUF BEIDEN SEITEN
** Unit-Tests (nur eine Klasse wird getestet, zB Entity-Klassen)
*** nicht nur Getter und Setter testen
*** eher eigene Logik (wenn etwas berechnet wird, equals-Methoden usw.)
*** wenn ein Setter/Getter eine beondere zusätzliche Logik hat, dann ist er sehr wohl zu testen

=== Arten von Beziehungen zwischen Objekten

==== Vererbung

[plantuml,vererbung,png]
----
@startuml
class Vehicle {
  brand: String
  model: String
}
class Pkw {
  isCabrio: boolean
}
class Lkw
Vehicle <|-- Lkw
Vehicle <|-- Pkw
@enduml
----

[source,java]
----
Pkw kaefer = new Pkw();
----

* 3 Strategien
** SINGLE_TABLE
** TABLE_CLASS (table per concrete class)
** joined

==== Aggregation

* besteht-aus, consists-of
* Objekte können zerstörungsfrei getrennt werden
* Bsp: Auto und Autoreifen

[plantuml,aggregation,png]
----
@startuml
Automobil o-- Reifen : aggregation
@enduml
----

==== Komposition

* besteht-aus, consists-of
* Objekte können nicht zerstörungsfrei getrennt werden
* Bsp
** Buch - Kapitel
** Haus - Etage

[plantuml,komposition,png]
----
@startuml
Haus *-- Etage : komposition
@enduml
----


==== Assoziation (<use>-Beziehung)

in verschiedenen Multiplizitäten (Kardinalität)

* 1:*
* 1:1
* \*:*

[plantuml,assoziation,png]
----
@startuml
Class1 "*" ---> "1" Class2 : assoziation >
Person "1" <--- "*" Hobby : übt aus >
@enduml
----

=== UML-Klassendiagramm

[plantuml,cld01,png]
----
@startuml
class Form {
  - urspung
  + verschieben()
  # foo()
}
@enduml
----

* Konvention -> Vereinbarung
* Signatur einer Methode: Scope + Rückgabewert + Methodenname + Parameterleiste
* Objekt (Object) = Instanz einer Klasse; mit Identität und Zustand

* Beispiel: PKW
** Anwendungsfall 1: Transport von Personen
** Anwendungsfall 2: Transport von Gütern
** Anwendungsfall 3: Cruisen auf der Landstraße (Statussymbol)

* Eigenschaften von Objekten
** Objektidentität

image:objektidentitaet.png[]

** Datenkapselung
image:datenkapselung.png[]

** Polymorphismus (Vielgestaltigkeit)

[plantuml,polym,png]
----
@startuml
class Animal {
  abstract say()
}
class Duck {
  say()
}
class Cat {
  say()
}
Animal <|-- Duck
Animal <|-- Cat
@enduml
----

[source,java]
----
Duck donald = new Duck();
donald.say(); // quack
Cat mimi = new Cat();
mimi.say(); // miau

List<Animal> animals = new LinkedList<>();
animals.add(donald);
animals.add(mimi);
animal.get(0).say(); // quack
annimal.get(1).say(); // miau
----

** Vererbung

==== Beziehungen zwischen Objekte

===== Generalisierung (Vererbung)

===== Assoziation

[plantuml,assoziation01,png]
----
@startuml
Person "Abeitnehmer\n1..*" --- "Arbeitgeber\n1" Firma: arbeitet für >
@enduml
----

.unidirektional
[plantuml,assoziation02,png]
----
@startuml
class Person{
  firma: Firma
}
Person "1..*" -r-> "1" Firma: arbeitet für >
@enduml
----

.unidirektional
[plantuml,assoziation03,png]
----
@startuml
class Person{
}
class Firma {
  belegschaft: List<Person>
}
Person "1..*" <-l- "1" Firma: arbeitet für >
@enduml
----

.bidirektional
[plantuml,assoziation04,png]
----
@startuml
class Person{
  - firma: Firma
  + setFirma()
}
class Firma {
  - belegschaft: List<Person>
  + addPerson()
}
Person "1..*" <-l- "1" Firma: hat Angestellte <
Person "1..*" -l-> "1" Firma: arbeitet für >
@enduml
----

.Beispiel: Automatisch ergänzen der anderen Seite
[source,java]
----
public class Person {
    public void setFirma(Firma firma) {
        if (firma != null && firma.isInstanceof(Firma.class)) {
          firma.addPerson(this);
        }
    }
}
----

===== Aggregation

* "Ganze-Teile"-Beziehung, die zerstörungsfrei zerlegt werden kann
* Bsp
** Auto + Autoreifen


===== Komposition

* "Ganze-Teile"-Beziehung, die *nicht* zerstörungsfrei zerlegt werden kann
* Bsp
** Haus + Stockwerk
** Buch + Kapitel



== 2020-12-15

https://github.com/htl-leonding-college/smallwind-quarkus[smallwind-demo]

[source,sql]
----
select c.CUST_COUNTRY, count(*)
from SW_CUSTOMER c
inner join SW_ORDERING SO on c.CUST_ID = SO.ORD_CUST_ID
group by c.CUST_COUNTRY;
----

https://www.objectdb.com/java/jpa/query/jpql/structure

[source,jpaql]
----
select o.customer.country, count(o) from Ordering o group by o.customer.country
----

* Bei Verwendung von JPA kann man sich den Join sparen, da eine Assoziation existiert.

== 2021-01-15

=== Panáche

siehe Quarkus-Lecture-Notes

bis Repository-Pattern (Bsp wurde erstellt)

=== Unterschied Spezifikation - Implementierung

==== Spezifikation
zB. JPA oder Jakarta Persistence

==== Implementierung
zB EclipseLink, Hibernate


=== Begriffe

* Surrogat ... Ersatz
* Ist ein Ersatz für einen natürlichen Schlüssel in einer relationalen DB.
* Ist ein künstlicher Schlüssel (Primary Key).
** Meist eine lfd. Nr., die von der DB hochgezählt wird.


* Begriffspaar transient/persistent
** transient ... flüchtig
** persistent ... dauerhaft (die Daten überleben den Prozess ihrer Entstehung)

* custom (im Gegensatz zu vorgegeben/vordefiniert/standardisiert)
** custom ... maßgeschneidert, der Benutzer kann sich etwas eigenes "bauen"

* Referenz
** Verweis auf etwas
** Beispiele
*** Referenzvariable verweist auf ein Objekt (refernziert ein Objekt)
*** Kundenreferenz verweist auf (hoffentlich zufriedene) Kunden meines Produkts
*** Referenzen in meinem Lebenslauf: verweisen auf vorhergegangene Arbeitgeber (die hoffentlich auch zufrieden waren)


== 2021-01-19

=== Panache

Live-Coding-Projekt: panache-person-demo

* Custom Id
* detached / attached
* UnitTest erstellt
* Unterschied @QuarkusTest und ohne Annotation
* Panache methods
** find mit Sort.by()
** paging


* Übung: Erweiterung des Microprojektes mit sinnvollen panache ...

* Übung 2:
** Vorbereiten des Codes, um in einem Endpoint, die einzelnen Seiten als JSON auszugeben
* Für Spezialisten: Verwendung von Qute, um Die Seiten als HTML gerendert auszugeben.


== 2021-01-21 - Angular

lecture-notes: https://htl-leonding-college.github.io/angular-lecture-notes/

https://nodejs.org/en/

https://developer.mozilla.org/de/docs/Glossary/HTML[Anatomy of an HTML element]

* Installieren von Node am Mac
** brew install

* Updaten von node am Mac
** brew update && brew upgrade && brew upgrade --cask


* Installieren auf Ubuntu
** sudo apt install nodejs

* Installieren unter Windows
** https://nodejs.org/dist/v14.15.4/node-v14.15.4-x86.msi

=== Angular Übungen

|===
|Angabe |Fällig

|https://github.com/2021-4ahitm-sew/turmrechnen-starter/blob/master/readme.adoc[Turmrechnen]
|

|https://github.com/2021-4ahitm-sew/todo-list-starter/blob/master/readme.adoc[TODO Liste]
|23.03.

|https://github.com/2021-4ahitm-sew/number-guessing-starter/blob/master/readme.adoc[Zahlen Raten]
|06.04.

|https://github.com/2021-4ahitm-sew/reusable_chart_starter/blob/master/readme.adoc[Wiederverwendbare Charts]
|20.04.

|===


== 2021-01-26

* Was ist ein:
** HTML - Element
** HTML - Attribute
** HTML - Tag

* format ... das aussehen betreffend
** zB Aussehen eines Word - Dokuments (fette Schrift, Schriftart, ...)
** zB die Datenstruktur: als JSON formatieren

* to render ... für die Ausgabe vorbereiten


== 2021-02-05

* Chapter 4. Templates and Data Binding
** 4.1. Interpolation
** 4.2. Event-Binding
** 4.3. Template Expressions
** 4.4. Property Binding
** 4.5. Two-Way-Binding
** 4.6. Structural Directive - *ngFor
** 4.7. Event with Parameter
** 4.8. Structural Directive - *ngIf
** 4.9. Exercise: Turmrechnen

== 2021-02-16



* Übungen
** https://angular.io/start#getting-started-with-angular[Getting started with Angular]
** https://angular.io/tutorial#tour-of-heroes-app-and-tutorial[Tour of Heroes app and tutorial]

TIP: After every unit commit into repo: https://classroom.github.com/a/_WHf3y1Q

IMPORTANT: each commit has to include your last name - ie Mueller - unit 1 / 1 Introduction to Angular

IMPORTANT: For every angular-project use an own branch

IMPORTANT: Never ever push node_modules into your git-repo

IMPORTANT: use -g when creating a new angular project, to avoid a mess with the git-repos

* https://developers.google.com/learn/topics/angular?hl=en

.Web-Frontends and Backend
image:web-frontends-and-backend.png[]

=== SPA - Single Page Application

== 2021-02-23

* https://classroom.github.com/a/lkNH8piU[Übung Turmrechnen]

== 2021-02-19

bis exklusive 5.2.4 Output Events


== 2021-02-23

image:dom.png[]


== 2021-02-26

bis exkl. 5.3. Exercise: Einheitenumrechner

== 2021-03-02

* https://classroom.github.com/a/hWIQYx05[Übung TODO Liste]

== 2021-03-09 (Gr.2)

* LZK02

Kap. 6 Accessing Web APIs

image:accessing-web-api.png[]

== 2021-03-16

* https://classroom.github.com/a/_ZqvzOLn[Übung Zahlen Raten]

* Vereinbarung
** Tour of Heroes bis zum nächsten mal
*** bis inkl. Kapitel 4: Services


[plantuml,webapi,png]
----
@startuml
node browser {
 component [angular app]
}
component quarkus
[quarkus] -- REST_api
[angular app] ..> REST_api
@enduml
----


* TODO: REST-Client in Angular-Technology-Notes überarbeiten

== 2021-03-23 - Gr B

* Services wurden besprochen

== 2021-03-26 - Distance Learning

.HTML-Attributes vs. DOM-properties
image:html-attibutes-vs-dom-prperties.png[]

* Nach den Ferien ist die Gruppe A anwesend

* Bis nach den Ferien ist das Tutorial "Tour of Heroes" fertigzustellen (Gr. A + Gr. B)

** Download der Repositories am 9. April 2021 -> wird bewertet



== 2021-04-09 (Fr.) - HttpClient & Routing


image:rest-overview.png[]

image:rest-jsonb-jsonp.png[]

* Angular HttpClient







* https://classroom.github.com/a/sMbpoMkj[Übung Line Charts]






