= Lecture Notes 4ahitm SEW 20/21
Thomas W. Stütz
1.0.0, 2020-09-25: Some notes
ifndef::imagesdir[:imagesdir: images]
//:toc-placement!:  // prevents the generation of the doc at this position, so it can be printed afterwards
:sourcedir: ../src/main/java
:icons: font
:sectnums:    // Nummerierung der Überschriften / section numbering
:toc: left

//Need this blank line after ifdef, don't know why...
ifdef::backend-html5[]

// https://fontawesome.com/v4.7.0/icons/
//icon:file-text-o[link=https://raw.githubusercontent.com/htl-leonding-college/asciidoctor-docker-template/master/asciidocs/{docname}.adoc] ‏ ‏ ‎
//icon:github-square[link=https://github.com/htl-leonding-college/asciidoctor-docker-template] ‏ ‏ ‎
//icon:home[link=https://htl-leonding.github.io/]
endif::backend-html5[]

====
Testtermin: 4.12.2020
Prüfungen:
====

== 2020-09-22

* http://edufs.edu.htl-leonding.ac.at/~t.stuetz/download/nvs/presentations.2021/00_java.oekosystem.pdf[00_java.oekosystem.pdf, window="_blank"]
* http://edufs.edu.htl-leonding.ac.at/~t.stuetz/download/nvs/presentations.2021/01_Introduction.pdf[01_Introduction.pdf, window="_blank"]
* http://edufs.edu.htl-leonding.ac.at/~t.stuetz/download/nvs/presentations.2021/01_NVS_Uebersicht.pdf[01a_NVS_Uebersicht.pdf, window="_blank"]
* http://edufs.edu.htl-leonding.ac.at/~t.stuetz/download/nvs/presentations.2021/02_microprofile.pdf[02_microprofile.pdf, window="_blank"]

[plantuml,twotier,png]
----
@startuml
database db
rectangle Quarkus as quarkus
rectangle Server
rectangle "Client (Browser)" as client

db -- quarkus
quarkus <-> Server : restful services
Server <- client : request
Server -> client : response
@enduml
----

== 2020-09-25

* Was ist ein REST-Service?

* Präsentation 04_REST_Uebersicht besprochen (bis Folie 20 - EFSP)
* http://edufs.edu.htl-leonding.ac.at/~t.stuetz/download/nvs/presentations.2021/02_microprofile.pdf[04_REST_Uebersicht, window="_blank"]

=== Begriff des Marshalling

[plantuml,marshalling,png]
----
@startuml
storage "java-object" as javaobject
file json
javaobject -right-> json :marshalling >
@enduml
----

[plantuml,unmarshalling,png]
----
@startuml
storage "java-object" as javaobject
file json
javaobject <-right- json :< unmarshalling
@enduml
----


== 2020-09-29

maven Lifecycle

=== Mögliche REST-Clients

* Browser
* Browser-Extension
** RESTClient
* REST-Client in IDE (files mit .http-Endung)
* CLI-clients
** cURL
** httpie `http :8080/person Accept:application/json`
* Standalone Clients
** Postman
** Insomnia
* Selbstprogrammierte Clients


=== MediaType in Produces

schränkt die möglichen MIME-Types ein


=== Rückgabetypen

* String
* Entity - Klasse
** JAXB - XML-Binding (XML-Marshalling)
** JSON-B - Json-Binding (Json-Marshalling)
* JsonObject / JsonArray / JsonValue
* Response
** Statuscode kann gewählt werden
** Header-Entries können hinzugefügt werden
** uvam.

== 2020-10-02

.Was ist? (Erläuterung und Abrenzung)
- Jakarta EE
- microprofile
- Quarkus

.Resourcen
- http://edufs.edu.htl-leonding.ac.at/~t.stuetz/download/nvs/presentations.2021/04_REST_Uebersicht.pdf[04_REST_Uebersicht.pdf, window="_blank"]


== 2020-10-06

* REST wiederholt
* POST & PUT Methoden erstellt und ausprobiert (CRUD)
* JsonValue, JsonObject & JsonArray verglichen
* Typen von Parametern besprochen
** https://mincong.io/2018/11/27/jax-rs-parameters/#overview


.Mikroprojekte - Themenvergabe
//[%collapsible%open]
[%collapsible]
====
[cols="1,5,5,2"]
|===
|lfd.Nr. |Name |Thema |-

|{counter:usage}
|BM
|Friedhofsverwaltung
|

|{counter:usage}
|DJ
|Produktionsbetrieb (Fließband)
|

|{counter:usage}
|DF
|Centermanager
|

|{counter:usage}
|EQ
|Baustellenkoordinator
|

|{counter:usage}
|EP
|Baumschule
|

|{counter:usage}
|FS
|Kochrezepte
|

|{counter:usage}
|FJ
|Farmverwaltung
|

|{counter:usage}
|HT
|Optiker
|

|{counter:usage}
|KS
|Facility Management
|

|{counter:usage}
|KF
|Zooverwaltung
|

|{counter:usage}
|KS2
|Event-Manager
|

|{counter:usage}
|MR
|Reisebüro
|

|{counter:usage}
|MA
|Plattenlabel
|

|{counter:usage}
|OJ
|Tanzschule
|

|{counter:usage}
|PV
|Skischule
|

|{counter:usage}
|RJ
|Fitnessstudio
|

|{counter:usage}
|SS
|Fakturierung
|

|{counter:usage}
|SL
|Kfz-Händler
|icon:uncheck[]

|{counter:usage}
|SM
|Friseurladen
|icon:uncheck[]

|{counter:usage}
|TS
|Restaurant
|icon:uncheck[]

|{counter:usage}
|TK
|Callcenter
|icon:uncheck[]

|{counter:usage}
|TI
|Busreisen (inkl Schulbusse)
|

|{counter:usage}
|WN
|Autovermietung
|

|{counter:usage}
|WJ
|Parkplatzverwaltung
|icon:uncheck[]

|===

====

=== Assignment 01: Erstellen von Endpoints für eine Entität mit CRUD-Funktionalität

* Erstellen Sie ein Quarkus-Projekt mit folgender Bezeichnung:
. nachname-projektname zB mustermann-restaurant
. Im Package `at.htl.<projektname>.entity` zB. `at.htl.restaurant.entity` erstellen Sie eine Entitätsklasse zB Product
   (in diesem Restaurant sind die Produkte die Speisen und Getränke)
. Die Daten der Stammdaten sind in einer Collection in einem geeigneten Repository zu speichern
(Es ist KEINE Datenbank zu verwenden).
. Im Package `at.htl.<projektname>.boundary` (zB `at.htl.restaurant.boundary`) erstellen
Sie ein Klasse <Entity>Service.java zB ProductService.java
. In dieser Klasse erstellen Sie mehrere Endpoints, um die CRUD-Funktionalität für die von Ihnen
gewählte Entität zu implementieren.
. In einem File `request.http` erstellen Sie die geeigneten Request, um ihre Endppoints auzuprobieren
. Die Requests funktionieren mit Daten wahlweise im JSON- oder XML-Format
. Verwenden Sie Swagger, um Ihre Endpoints zu dokumentieren
. Im README.md ihres Repos dokumentieren Sie dieser (erste) Aufgabe rudimentär.
. Vergessen sie nicht, die nicht in das github-repo zu speichernden Dateien zu exkludieren.
. Für jeden Endpoint ist ein Commit mit einer aussagekräftigen Message zu erstellen.
. *Abgabe bis 12.Oktober 2020, 23:59*
. Den Link zum Classroom-Repository finden Sie im Discord.

TIP: Verwenden Sie eine Stammdatenklasse.

----
____   ____.__       .__    ___________        _____      .__
\   \ /   /|__| ____ |  |   \_   _____/_______/ ____\____ |  |    ____
 \   Y   / |  |/ __ \|  |    |    __)_\_  __ \   __\/  _ \|  |   / ___\
  \     /  |  \  ___/|  |__  |        \|  | \/|  | (  <_> )  |__/ /_/  >
   \___/   |__|\___  >____/ /_______  /|__|   |__|  \____/|____/\___  /
                   \/               \/                         /_____/
----

== 2020-10-13

=== Testen Allgemein

* Unterschied
** Unit Test
** Integration Test
* TDD
* Coverage
** Wie viel macht Sinn
*** Happy Path & Edge Cases
*** Was muss man eventuell nicht automatisiert(!) testen
** mehrere mögliche Programmläufe durch Verzweigungen

=== Quarkus Tests

* Besprechung was im Hintergrund eigentlich alles passiert
* Syntax (& Packages)
* Was sollte man damit testen
* Tests gemeinsam erstellt für:
** Statuscode
** Body Content

== Benotung Assignment 1 - Entities mit CRUD - Funktionalität

Noten sind (demnächst) im
https://edufs.edu.htl-leonding.ac.at/moodle/course/view.php?id=2931[Moodle-Kurs]
abrufbar.


.Bewertung Assignment 1 - Download am 2020-10-14 11:42
[%collapsible%open]
//[%collapsible]
====
[cols="1,1,8,2"]
|===
|lfd.Nr. |Name |Kommentar |Note

|{counter:katalognr}
|BM
a|
* Thema: Friedhofsverwaltung
* nicht lauffähig
* keine Endpoints
* das heißt nicht cementry, sondern CEMETERY oder GRAVEYARD
* Dir fehlen sämtliche Projektdateien (mvnw, pom.xml, .gitignore, ...)
* Felder in einer Klasse sind private (-> Geheimnisprinzip)
+
[source,java]
----
public class Person {

    Integer id;
    String name = "";
    LocalDateTime bday;
    String causeOfDeath = "";

    public Person(Integer id, String name, LocalDateTime bday, String causeOfDeath) {
        this.id = id;
        this.name = name;
        this.bday = bday;
        this.causeOfDeath = causeOfDeath;
    }
    //...
}
----
** besser wäre eine Entität Grab(*`grave`*), die ist wohl am Wichtigsten
(mit einem Feld `Ansprechperson` (`contact`))
** Person ist schon ok, aber erst später. BTW: Die Todesursache geht keinen was an
(ev. auch hier eine Kontaktperson i.S.v. Kunde)
|ngd(5)

|{counter:katalognr}
|DJ
a|
* Thema: Produktionsbetrieb (Fließband)
* sehr ausführliche Dokumentation im README.md
* .gitignore
** Wenn Du den gesamten `.idea`-Ordner ausschließt, verlierst Du auch jedes mal Deine Datasources etc
** besser ist es, nur `workspace.xml` auszuschließen
* PATCH fehlt
* employee.http hat falsche urls

*Bravo*
|sgt(1)

|{counter:katalognr}
|DF
a|
* Thema: Centermanager
* Einen Schönheitspreis gewinnt Dein Algorithmus nicht
image:dumfarth-string-concat.png[]
** StringBuilder?
** sprechende Methodennamen: hello(...) ?
* Du hättest ev. auch mal einen Objekttyp (Entityklasse) als Parametertyp nehmen können
* Wenn Du sowieso nur ein JsonObject erwartest, dann kannst Du ruhig JsonObjekt als Datentyp nehmen und nicht immer JsonValue
* Bei einem REST-Endpoint keine Webseiten zurückgeben (auch wenn es gut aussieht) -> Stichwort: maschinenlesbar
image:dumfahrt-get.png[]
** Für Webseiten kannst Du index.html verwenden
** besser JSON, XML, ...
* Testdaten -> Bravo
|sgt(1)

|{counter:katalognr}
|EQ
a|
* Thema: Baustellenkoordinator
* sehr aufmerksam -> XmlLocalDateAdapter

.Implementierung des XmlAdapters
[source,java]
----
import javax.xml.bind.annotation.adapters.XmlAdapter;
import java.time.LocalDate;

public class XmlLocalDateAdapter extends XmlAdapter<String, LocalDate> {


    @Override
    public LocalDate unmarshal(String s) {
        return LocalDate.parse(s);
    }

    @Override
    public String marshal(LocalDate localDate) {
        return localDate.toString();
    }
}
----

.Verwendung des XmlAdapters
[source,java]
----
@XmlRootElement
public class Construction {
    // ...
    @XmlJavaTypeAdapter(value = XmlLocalDateAdapter.class)
    public void setDeadLine(LocalDate deadLine) {
        this.deadLine = deadLine;
    }
    // ...
}
----

see also https://blog.sebastian-daschner.com/entries/jaxrs-convert-params[Converting JAX-RS parameters with ParamConverters, window="_blank"]

* Response beim POST nicht korrekt, aber fast
----
POST http://localhost:8080/constructions

HTTP/1.1 201 Created
Content-Length: 0
Location: http://localhost:8080/constructions  //<.>

<Response body is empty>

Response code: 201 (Created); Time: 28ms; Content length: 0 bytes
----

<.> hier sollte die Resource *des Elements* stehen

.ConstructionService
[source,java]
----
@Path("/constructions")
public class ConstructionService {
    //...
    @POST
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    public Response create(Construction construction, @Context UriInfo uriInfo) {
        ConstructionRepository
                .getInstance()
                .create(construction);  // <.>

        return Response.created(uriInfo
                .getAbsolutePathBuilder()
                 //.path(Integer.toString(id))
                .build())
                .build();
    }
    //...
}
----

<.> hier wäre die Rückgabe des Schlüssels vorteilhaft,
der dann in die Location hinzugefügt werden kann
(siehe auskommentierten Code).

* Git-Commits ok

|sgt(1)

|{counter:katalognr}
|EP
a|
* Thema: Baumschule
* gut in README.md dokumentiert
* Aktueller Quarkus 1.8.1
* leider keine vollständige CRUD-Funktionalität
|bef(3)

|{counter:katalognr}
|FS
a|
* Thema: Kochrezepte
* Die geborene Köchin
image:feichtinger-putenschnitzel.png[]
* Für die Parameter gilt das selbe wie bei Felix
* Für Deine Algorithmen gilt ebenfalls exakt dasselbe wie bei Felix
* Testdaten -> Bravo (ebenfalls wie bei Felix)
| sgt(1)

|{counter:katalognr}
|FJ
a|
* Thema: Farmverwaltung
* Tolle Farmverwaltung

.Product.java
[source,java]
----
package at.htl.fitzinger_farmverwaltung.entity;

public class Product {
}
----

.ProductService.java
[source,java]
----
package at.htl.fitzinger_farmverwaltung.boundary;

public class ProductService {
}
----

.ProductRepository.java
[source,java]
----
package at.htl.fitzinger_farmverwaltung.entity;

import java.util.ArrayList;

public class ProductRepository {
    ArrayList<Product> products = new ArrayList<Product>();
}
----
|ngd(5)

|{counter:katalognr}
|HT
a|
* Thema Optiker
* nur leere Klassen

[source,java]
----
package at.htl.hoefler_optiker.entity;

public class Product {
}
----

[source,java]
----
package at.htl.hoefler_optiker.entity;

import java.util.ArrayList;

public class ProductRepository {
    ArrayList<Product> productList = new ArrayList<Product>();
}
----
|ngd(5)

|{counter:katalognr}
|KS
a|
* Thema: Facility Management
* Sehr witzig, wo sind die ganzen maven-Files?
image:kalinke-project-contents.png[]
+
image:klausner-leeres-repo.png[]

* Warum gibst Du immer eine Liste zurück?

[source,java]
----
public class BuildingRepository {

    private final List<Building> buildings = new ArrayList<>();

    //...
    public List<Building> addEntity(Building building) {
        buildings.add(building);
        return buildings;
    }

    public List<Building> removeEntity(Building buildingToRemove) {
        for (Building buildingEntry : buildings) {
            if (buildingEntry.getType().equals(buildingToRemove.getType())) {
                buildings.remove(buildingEntry);
                return buildings;
            }
        }
        return buildings;
    }
    //...
}


----
* Das ist *keine* CRUD-Funktionalität (nur GET)
+
image:kalinke-crud.png[]
|gen(4)

|{counter:katalognr}
|KF
a|
* Thema: Zooverwaltung
* leider leeres Repo abgegeben
|ngd(5)

|{counter:katalognr}
|KS2
a|
* Thema: Event-Manager
* völlig leer, nicht mal ein leeres Projekt
|ngd(5)

|{counter:katalognr}
|MR
a|
* Thema: Reisebüro
* .gitignore -> siehe Dorfinger
* `http://localhost:8080/reise` -> siehe Dumfarth
** Ist cool gelöst, mit den unterschiedlichen MIME-Types
|sgt(1)

|{counter:katalognr}
|MA
a|
- Thema: Plattenlabel
- nur 2 leere Klassen (Label und Mitarbeiter)
- Anmerkung: Klassen sollten englisch benannt werden
|ngd(5)

|{counter:katalognr}
|OJ
a|
* Thema: Tanzschule
* Im `jonasoirer`-Repo hast Du ein Verzeichnis `oirer-tanzschule`,
in dem man dann das Projektverzeichnis `oirer-tanzschule` findet.
-> *Das ist eindeutig zu tief verschachtelt* +
+
image:oirer-folder-structure.png[width=300]
* Beim Repository ist eine Datenelement einzufügen (add),
nicht die bestehende Collection durch eine andere zu ersetzen (set)
+
[source,java]
----
public class DancingRepository {

    private List<DancingTeacher> repository = new ArrayList<>();

    public DancingRepository() {
        setRepository();
    }

    private void setRepository() {
        repository.add(new DancingTeacher(1, "Jonas", "Oirer"));
        repository.add(new DancingTeacher(2, "Aleks", "Vidakovic"));
    }

    public List<DancingTeacher> getRepository() {
        return repository;
    }

    @Override
    public String toString() {
        return "DancingRepository{" +
                "repository=" + repository +
                '}';
    }
}
----

** Man kann nichts hinzufügen
** Man kann nichts löschen
** Man kann nichts ändern
** Man kann kein einzelnes Datenelement abrufen
* Deine Packages und Klassen sind unstrukturiert
image:oirer-packages.png[]
** in das Package entity gehören nur entity-Klassen, keine Endpoints und auch kein Repository
* openapi / swagger sind *NICHT* installiert
* dein request.http ist
** unvollständig und
** fehlerhaft (PUT ohne body)
* Was ist da nicht optimal?
+
[source,java]
----
@Path("/dancer")
public class DancingTeacherService {
    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String hello() {
        return "hello oiropean dancers!";
    }

    private String coolestTeacher;

    @PUT
    @Path("coolest")
    @Consumes(MediaType.APPLICATION_JSON)
    public String getCoolestTeacher(DancingTeacher dancingTeacher) {
        this.coolestTeacher = dancingTeacher.getFirstName();
        return String.format("%s is the best", this.coolestTeacher);
    }
}
----

* Routen sollten nie im camel-Case sein, sondern kebab-case
|gen(4)

|{counter:katalognr}
|PV
a|
* Thema: Skischule
* sehr umfangreich

|sgt(1)

|{counter:katalognr}
|RJ
a|
* Thema: Fitnessstudio
* leider nur ein leeres Projekt abgegeben
|ngd(5)

|{counter:katalognr}
|SS
a|
* Thema: Fakturierung
* Die Bezeichner (der Klassen) sollten englisch sein
* Die Requests funktionieren nur im JSON-Format. Nicht wie in der Angabe gefordert auch im XML-Format
|sgt(1)

|{counter:katalognr}
|SL
a|
* Thema: Kfz-Händler
* Sehr umfangraich und sauber
* Ein Datum wäre gut gewesen
|sgt(1)

|{counter:katalognr}
|SM
a|
* Thema Friseurladen
* das kann wohl nicht funktionieren!
** Wo wird der bodey des requests eingelesen
** keine Groß-/Kleinschreibung bei Routen
** Du legst bei jedem Request ein eigenes Repository an (?!)

[source,java]
----
@Path("/person")
public class FriseurService {
    //...
    @POST
    @Path("/friseurJSON")
    @Produces(MediaType.APPLICATION_JSON)
    public List<Friseur> getFriseurList(){
        if (repository.friseure.size()== 0) {
            repository.createRepository();
        }
            return repository.friseure;
    }
    //...
}
----
|bef(3)

|{counter:katalognr}
|TS
a|
* Thema Restaurant
* beim POST muss man sicherstellen, dass bei mehrmaligen ausführen das Element nur einmal hinzugefügt wird
* es ist aber sehr sauber programmiert
|sgt(1)

|{counter:katalognr}
|TK
a|
* Thema: Callcenter
* Dir fehlen sämtliche Projektdateien (mvnw, pom.xml, .gitignore, ...)
* Die Klassennamen sollten immer in Englisch sein (alle Bezeichner)
* CRUD nicht vollständig implementiert
* nicht lauffähig
|gen(4)

|{counter:katalognr}
|TI
a|
* Thema: Busreisen (inkl Schulbusse)
* Grundsätzlich sehr sauber
* Es sollte auch möglich sein, nur einzelne Elemente zu lesen
* Warum ist beim GET nur XML möglich?
* Du solltest packages verwenden
* git commits sind ok
|gut(2)

|{counter:katalognr}
|WN
a|
* Thema Autovermietung
* Image-Links in README.md broken
* git-kommentar "zwischencommit" ist nicht sehr sprechensd
* Man sollte ein Element nur einmal posten können
** beim POST muss man sicherstellen, dass bei mehrmaligen ausführen das Element nur einmal hinzugefügt wird
|sgt(1)

|{counter:katalognr}
|WJ
a|
* Thema Parkplatzverwaltung
* ad README.md -> Du solltest Dir wirklich ansehen, wie man images in markdown files verlinkt
* Du Minimalist
|sgt(1)

|===

.Kriterien
* Das Projekt muss lauffähig sein (am Besten in ein neues Verzeichnis clonen und ausprobieren)
* Testdaten sind sehr hilfreich

.Allgemeine Bemerkungen
* Bezeichner in englisch (ist so üblich)
* ist eine List wirklich die geeignete Collection für das Repository
* der erste url einer RESTful-API sollte `/api` sein  (ebenfalls sehr oft üblich)

.Was ist zu tun
* Fehlerbehandlung -> WebException
* Wie sind die Responses aufgebaut?
* Kalenderdatum als Parameter bzw Datenbestandteil

====



== 2020-11-06 CDI - Context and Dependency Injection

http://edufs.edu.htl-leonding.ac.at/~t.stuetz/download/nvs/presentations.2021/07%20CDI.pdf[Skriptum CDI]

* Scope ... (Gültigkeits-)Bereich
** zB Gültigkeitsbereich bei Variablen (i.N. ein Block)
** zB Lebensdauer von Objekten (ApplicationScoped, SessionScoped, RequestScoped)
** ...

* CDI
** C ... Context ... Lebensdauer der Objekte
** DI ... Dependency Injection ... Injizieren einer Abhängigkeit

* Was bringt CDI?
** Inversion of Control / IoC: Das Programm muss sich nicht  mehr um die Erstellung
von Objekten kümmern, das übernimmt der Container
** Dies führt zu wenig fehleranfälligen Programmen
*** Um Erstellen/Zuweisen/Löschen der Objekte kümmert sich der Container
*** Man kann einfach die Konfiguration ändern
**** Testcontainer mit Testobjekten
**** Produktiv-Containe mit Real-Life-Objekten

* https://www.dev-insider.de/was-ist-eine-dependency-a-899057/[Dependency, window="_blank"]
** Eine Dependency oder Abhängigkeit beschreibt in der Softwareentwicklung, dass ein Programm ein bestimmtes Stück Code (z. B. Frameworks, Bibliotheken, Klasse) benötigt, um ordnungsgemäß zu funktionieren.

* Wie kann ein Objekt erstellt werden?
** Durch Verwendung des Schlüsselwortes `new`
** Durch Verwendung von Design Patterns (Entwurfsmuster)
*** zB einer Factory (Design Pattern)
*** zB eines Builder Pattern (Erbauer)
** Durch Dependency Injection

.Objekterstellung mit "new"
image:object-creation-with-new.png[]

* Erstellt man ein Objekt mit "new", so ist man selbst für die Lebensdauer verantwortlich
** Man kann das obige Person-Objekt löschen, indem man die Referenz auf das Objekt löscht
** Der Garbage Collector gibt den Speicherpaltz des Objekts frei.

.Durch NULL-setzen der Refernzvariablen wird der Speicherplatz freigegeben.
image:objcect-deletion.png[]

* Bei CDI ist der sogenannte DI-Container verantwortlich für
** das Erstellen von Objekten
** das Zuweisen zu einem Context (Lebensdauer)
** das Zuweisen von Objekten zu Variablen
** das Löschen von Objekten (Freigeben des Speicherplatzes)
** man spricht von "container-managed" Objekten oder auch Java-Beans
** Durch Verwendung von Annotation (@ApplicationScoped, @SessionScoped, @RequestScoped) kann
man die Lebensdauer beeinflussen.
** Mit *@Inject* kann der Developer eine Instanz einer Klasse anfordern.

* The *container* is the environment where your application runs.

* Was ist ein *Servlet*
** Ein Servlet ist *DIE* Methode, um Java-Code aus dem Internet (mittels TCP/IP))
aufrufen zu können
** Viele Bibliotheken zB JAX-RS, JSF usw verwenden im Hintergrund Servlets.


=== Logging in Jakarta EE (Quarkus)

https://quarkus.io/guides/logging

* Es wird empfohlen den jboss-Logger zu verwenden.


[source,java]
----
@ApplicationScoped
public class GreetingService {

    private static final Logger logger = Logger
            .getLogger(GreetingService.class.getSimpleName()); // <.>

    int counter;

    public String greeting(String name) {
        logger.info(String.format("Hello %s (%d x verwendet)", name, ++counter)); // <.>
        return String.format("Hello %s (%d x verwendet)", name, ++counter);
    }
}
----
<.> Man muss einen Logger deklarieren. Der Klassenname wird übergeben.
<.> Man kann den Logger verwenden

.Output des Loggers in Console
----
2020-11-06 09:40:53,795 INFO  [at.htl.con.GreetingService] (executor-thread-198) Hello susi (1 x verwendet!)
----

* Es gibt *Log-Levels*
** INFO
** ERROR
** FATAL
** DEBUG
** ...

* Es gibt sogenannte *Appender* zur Ausgabe auf verschiedenen Medien
** Konsole
** in Text-Files (auch rotierend)
** in Datenbanken
** auf einen REST-Endpoint
** ...

==== Logging mit Dependency Injection

Man kann auch einen Logger mit DI injizieren

.Erstellen des Producers
[source,java]
----
public class LoggerProducer {

    @Produces
    public Logger produceLogger(InjectionPoint injectionPoint) {
        return Logger.getLogger(injectionPoint.getBean().getBeanClass());
    }
}
----

.Verwendung des injizierten Loggers
[source,java]
----
@ApplicationScoped
public class GreetingService {

    @Inject
    private Logger logger; // <.>

    int counter;

    public String greeting(String name) {
        logger.info(String.format("Hello %s (%d x verwendet!)", name, ++counter)); // <.>
        return String.format("Hello %s (%d x verwendet!)", name, ++counter);
    }

}
----

<.> Die Logger Klasse wird injiziert.
<.> Die Verwendung bleibt gleich


=== Offene Punkte

* Warum funktioniert CDI nicht im Constructror?
* Was kann ich machen, um trotzdem CDI bei der Erstellung von Objekten zu verwenden? -> @PostConstruct
* Autostart in Quarkus-Apps (@Observer)